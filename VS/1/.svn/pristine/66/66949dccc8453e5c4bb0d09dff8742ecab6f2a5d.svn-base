#include <vfilesystem_api.h>

int currId = 0;

typedef struct Folder{
	FolderID id;
	FolderID parent;
	char* name;
	struct Folder* next;
}Folder;

typedef struct File{
	FileID id;
	FolderID parent;
	char* name;
	struct File* next;
	/* inhalt */
}File;

Folder* folderStart;
File* fileStart;

int folderExists(FolderID id){
	if(id < 0) return 0;
	if(id == 0 && currId == 1) return 1;
	Folder* list = folderStart;
	/*liste durchlaufen*/
	while(list != NULL){
		if(list->id == id){
			return 1;
		}
		list = list->next;
	}
	return 0;
}

int fileExists(FileID id){
	File* list = fileStart;
	if(id < 0) return 0;
	if(id == 0 && currId == 1) return 1;
	while(list != NULL){
		if(list->id == id){
			return 1;
		}
		list = list->next;
	}
	return 0;
}

FolderID fs_init() {
	if(currId == 0){
		folderStart = calloc(1,sizeof(Folder));
		folderStart->id = currId;
		folderStart->parent = -1;
		folderStart->name = "root";
		folderStart->next = NULL;
		currId++;
	}
	return 0;
}

void fs_destroy() {
	Folder* tmpFo;
	File* tmpFi;
	while(folderStart != NULL){
		tmpFo = folderStart;
		folderStart = folderStart->next;
		free(tmpFo); 
	}
	while(fileStart != NULL){
		tmpFi = fileStart;
		fileStart = fileStart->next;
		free(tmpFi); 
	}
}

FileID fs_new_file(char *name, FolderID parent){
	if(!folderExists(parent)) return INVALID_HANDLE; /*---------------------------------------------------*/
	return 0;
}

FolderID fs_new_folder(char *name, FolderID parent){
	Folder* list = folderStart;
	Folder* new = calloc(1,sizeof(Folder));
	if(!folderExists(parent)) return INVALID_HANDLE;
	new->id = currId;
	new->parent = parent;
	new->name = name;
	new->next = NULL;
	currId++;
	while(list->next != NULL){
		list = list->next;
	}
	list->next = new;
	return new->id;
}

int32_t fs_delete_file(FileID file) {	
	File* list = fileStart;
	File* tmp;
	if(list->id == file){
		tmp = list;
		list = list->next;
		free(tmp);
		return 0;
	}
	while(list != NULL){
		if(list->next->id == file){
			tmp = list->next;
			list->next = tmp->next;
			free(tmp);
			return 0;
		}
	}
	return -1;
}

int32_t fs_delete_folder(FolderID folder) {
	Folder* list = folderStart;
	Folder* tmp;
	while(list != NULL){
		if(list->parent == folder) return -1;
		list = list->next;
	}
	list = folderStart;
	if(list->id == folder){
		tmp = list;
		list = list->next;
		free(tmp);
		return 0;
	}
	while(list != NULL){
		if(list->next->id == folder){
			tmp = list->next;
			list->next = tmp->next;
			free(tmp);
			return 0;
		}
	}
	return -1;
}

FolderID fs_get_file_parent(FileID file) {
	return 0;
}

int32_t fs_get_file_size(FileID file) {
	return 0;
}

int32_t fs_get_file_name_length(FileID file) {
	return 0;
}

int32_t fs_get_file_name(FileID file, char* file_name, uint8_t max_length) {
	return 0;
}

FolderID fs_get_folder_parent(FolderID folder) {
	return 0;
}

int32_t fs_get_folder_name_length(FolderID folder) {
	return 0;
}

int32_t fs_get_folder_name(FolderID folder, char* folder_name, uint32_t max_length) {
	return 0;
}

int32_t fs_get_folder_file_count(FolderID folder) {
	return 0;
}

int32_t fs_get_folder_folder_count(FolderID folder) {
	return 0;
}

int32_t fs_get_folder_files(FolderID folder, FileID* files, uint32_t max_num_files) {
	return 0;
}

int32_t fs_get_folder_folders(FolderID folder, FolderID* folders, uint32_t max_num_folders) {
	return 0;
}

int32_t fs_write_file(FileID file, uint32_t offset, uint32_t length, uint8_t *data){
	return 0;
}

int32_t fs_read_file(FileID file, uint32_t offset, uint32_t length, uint8_t *data){
	return 0;
}
